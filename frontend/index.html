<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deck Registrierung</title>
    <link rel="stylesheet" href="/static/styles.css">
</head>
<body>
    <div class="glass-card">
        <h1>
            {% if start_file_exists %}
                Deck Verteilung
            {% else %}
                Deck Registrierung
            {% endif %}
        </h1>

        <!-- Bedingte Anzeige basierend auf deck_id und start_file_exists -->
        {% if deck_id == 0 %}
            {% if start_file_exists %}
            <p class="status ok">
                Bitte scant jetzt noch mal die Decks, und verteilt Sie wie angegeben.
            </p>
            {% else %}
            <p class="status danger">
                Bitte warte, bis alle Decks registriert wurden.
            </p>
            {% endif %}
        {% elif existing_entry %}
        {% if start_file_exists %}
        <p class="status">
            Bitte übergebe dieses Deck an
            <span class="status ok" style="display:inline-block; padding:4px 8px; margin-left:6px;">
                {{ deckOwner }}
            </span>
        </p>
        {% else %}
        <p class="status danger">
            Dieses Deck wurde bereits registriert. Bitte warte bis der Raffle startet.
        </p>
        {% endif %}
        {% else %}
            <!-- Fehleranzeige -->
            {% if error %}
            <div class="status danger">
                {{ error }}
            </div>
            {% endif %}

            <!-- Formular -->
            <form action="/submit" method="post">
                <label for="deckersteller">Name des Deckerstellers:</label>
                <select id="deckersteller" name="deckersteller" required>
                    <option value="" disabled selected>Wählen Sie einen Namen</option>
                    {% for name in participants %}
                    <option value="{{ name }}" {% if values and values.get('deckersteller') == name %}selected{% endif %}>{{ name }}</option>
                    {% endfor %}
                </select>
                <br><br>

                <label for="commander">Name des Commanders:</label>
                <div class="suggest-wrap">
                    <input type="text" id="commander" name="commander" class="commander-input" autocomplete="off"
                        value="{{ values.commander if values }}" placeholder="z.B. Akroma (sucht auf Scryfall)">
                    <div id="commanderSpinner" class="input-spinner"></div>
                    <div id="commanderSuggestBox" class="suggest-box"></div>
                </div>
                <br><br>

                <div id="commander2Wrap">
                    <label for="commander2">Commander 2:</label>
                    <div class="suggest-wrap">
                        <input type="text" id="commander2" name="commander2" class="commander-input" autocomplete="off"
                            value="{{ values.commander2 if values }}"
                            placeholder="Partner (freigeschaltet, wenn partnerfähiger Commander ausgewählt ist)"
                            disabled>
                        <div id="commander2Spinner" class="input-spinner"></div>
                        <div id="commander2SuggestBox" class="suggest-box"></div>
                    </div>
                    <br><br>
                </div>


                <label for="deckUrl">DeckURL z.B. Moxfield (Optional):</label>
                <input type="url" id="deckUrl" name="deckUrl" value="{{ values.deckUrl if values }}">
                <br><br>

                <!-- Hidden Input für DeckID -->
                <input type="hidden" name="deck_id" value="{{ deck_id }}">

                <div class="btn-row">
                    <button type="reset">Reset</button>
                    <button type="submit">Send</button>
                </div>
            </form>
        {% endif %}

        <script>
        (() => {
            const MIN_CHARS = 3;
            const DEBOUNCE_MS = 350;

            const commander1Input = document.getElementById("commander");
            const commander1Box = document.getElementById("commanderSuggestBox");
            const commander1Spinner = document.getElementById("commanderSpinner");

            const commander2Input = document.getElementById("commander2");
            const commander2Box = document.getElementById("commander2SuggestBox");
            const commander2Spinner = document.getElementById("commander2Spinner");

            // Track “confirmed” selection for commander 1:
            // Commander 2 is only enabled when commander1ConfirmedName is set AND partner_capable.
            let commander1ConfirmedName = null;

            function setSpinner(spinnerEl, isLoading){
                if (!spinnerEl) return;
                spinnerEl.classList.toggle("show", !!isLoading);
            }

            function setBackground(url, zoom){
                if (url !== undefined && url !== null) {
                document.documentElement.style.setProperty('--bg-image', `url("${url}")`);
                }
                if (zoom !== undefined && zoom !== null) {
                document.documentElement.style.setProperty('--bg-zoom', String(zoom));
                }
            }

            async function loadDefaultBackground(){
                try{
                const r = await fetch("/api/background/default", { cache:"no-store" });
                if(!r.ok) return;
                const data = await r.json();
                if(data && data.url){
                    setBackground(data.url, data.zoom || 1.12);
                }
                }catch(_){}
            }

            async function loadCommanderBackground(name){
                try{
                const r = await fetch(`/api/background/commander?name=${encodeURIComponent(name)}`, { cache:"no-store" });
                if(!r.ok) return;
                const data = await r.json();
                if(data && data.url){
                    setBackground(data.url, data.zoom || 1.0);
                }
                }catch(_){}
            }

            async function checkPartnerCapable(name){
                try{
                const r = await fetch(`/api/commander_partner_capable?name=${encodeURIComponent(name)}`, { cache:"no-store" });
                if(!r.ok) return false;
                const data = await r.json();
                return !!(data && data.partner_capable);
                }catch(_){
                return false;
                }
            }

            function setCommander2Enabled(enabled){
                if (!commander2Input) return;
                commander2Input.disabled = !enabled;
                if (!enabled) {
                commander2Input.value = "";
                hideBox(commander2Box);
                }
            }

            function escapeHtml(s){
                return String(s)
                .replaceAll("&","&amp;")
                .replaceAll("<","&lt;")
                .replaceAll(">","&gt;")
                .replaceAll('"',"&quot;")
                .replaceAll("'","&#039;");
            }

            function hideBox(boxEl){
                if(!boxEl) return;
                boxEl.style.display = "none";
                boxEl.innerHTML = "";
            }

            function renderBox(boxEl, names){
                if(!boxEl) return;
                if(!names || names.length === 0){
                hideBox(boxEl);
                return;
                }
                boxEl.innerHTML = names
                .map(n => `<div class="suggest-item" data-name="${escapeHtml(n)}">${escapeHtml(n)}</div>`)
                .join("");
                boxEl.style.display = "block";
            }

            function attachSuggest({ inputEl, boxEl, spinnerEl, endpointUrlBuilder, onPicked }){
                if(!inputEl || !boxEl) return;

                let timer = null;
                let lastQuery = "";
                let inFlight = false;

                async function fetchSuggest(q){
                if(inFlight) return;
                inFlight = true;
                setSpinner(spinnerEl, true);
                try{
                    const url = endpointUrlBuilder(q);
                    const resp = await fetch(url, { cache:"no-store" });
                    if(!resp.ok){ hideBox(boxEl); return; }
                    const data = await resp.json();
                    if(q !== lastQuery) return;
                    renderBox(boxEl, data);
                }catch(_){
                    hideBox(boxEl);
                }finally{
                    setSpinner(spinnerEl, false);
                    inFlight = false;
                }
                }

                inputEl.addEventListener("input", () => {
                const q = inputEl.value.trim();
                lastQuery = q;

                // If user edits text, they are no longer “confirmed” unless it matches confirmed value exactly.
                if (inputEl === commander1Input) {
                    if (!q) {
                    commander1ConfirmedName = null;
                    setCommander2Enabled(false);
                    loadDefaultBackground();
                    } else if (commander1ConfirmedName && q !== commander1ConfirmedName) {
                    // partner confirmation invalidated
                    commander1ConfirmedName = null;
                    setCommander2Enabled(false);
                    }
                }

                if(q.length === 0){
                    setSpinner(spinnerEl, false);
                    hideBox(boxEl);
                    return;
                }
                if(q.length < MIN_CHARS){
                    setSpinner(spinnerEl, false);
                    hideBox(boxEl);
                    return;
                }

                clearTimeout(timer);
                timer = setTimeout(() => fetchSuggest(q), DEBOUNCE_MS);
                });

                boxEl.addEventListener("click", async (ev) => {
                const item = ev.target.closest(".suggest-item");
                if(!item) return;
                const name = item.getAttribute("data-name");
                inputEl.value = name;
                hideBox(boxEl);
                if(onPicked) await onPicked(name);
                });

                document.addEventListener("click", (ev) => {
                if(ev.target === inputEl || boxEl.contains(ev.target)) return;
                hideBox(boxEl);
                });

                inputEl.addEventListener("keydown", (ev) => {
                if(ev.key === "Escape") hideBox(boxEl);
                });
            }

            // initial background
            document.addEventListener("DOMContentLoaded", () => {
                const current = (commander1Input?.value || "").trim();
                if (!current) loadDefaultBackground();
                else loadCommanderBackground(current);

                // Commander 2 should be disabled until Commander 1 is confirmed via click + partner-capable.
                setCommander2Enabled(false);
            });

            // --- WebSocket live reload (unchanged from your version) ---
            const currentDeckId = Number("{{ deck_id }}") || 0;

            function wsUrl(params){
                const proto = (location.protocol === "https:") ? "wss" : "ws";
                return `${proto}://${location.host}/ws?${params}`;
            }

            function connectWS(){
                const params = (currentDeckId !== 0)
                ? `deck_id=${encodeURIComponent(currentDeckId)}`
                : "channel=home";

                const ws = new WebSocket(wsUrl(params));
                let pingTimer = null;

                ws.onmessage = (ev) => {
                if (ev.data === "pong") return;

                let msg;
                try{ msg = JSON.parse(ev.data); }catch(_){ return; }

                if(currentDeckId === 0 && msg.type === "state_changed" && msg.scope === "global"){
                    location.reload();
                    return;
                }

                if(currentDeckId !== 0 && msg.type === "state_changed" && msg.scope === "deck" && msg.deck_id === currentDeckId){
                    location.reload();
                }
                };

                ws.onopen = () => {
                pingTimer = setInterval(() => {
                    if(ws.readyState === 1) ws.send("ping");
                }, 25000);
                };

                ws.onclose = () => {
                if (pingTimer) clearInterval(pingTimer);
                setTimeout(connectWS, 1000);
                };

                ws.onerror = () => {
                try { ws.close(); } catch(_) {}
                };
            }

            document.addEventListener("DOMContentLoaded", connectWS);

            // Commander 1 suggest
            attachSuggest({
                inputEl: commander1Input,
                boxEl: commander1Box,
                spinnerEl: commander1Spinner,
                endpointUrlBuilder: (q) => `/api/commander_suggest?q=${encodeURIComponent(q)}`,
                onPicked: async (name) => {
                commander1ConfirmedName = name;              // confirmed via click
                await loadCommanderBackground(name);

                const partnerCapable = await checkPartnerCapable(name);
                if (partnerCapable) {
                    setCommander2Enabled(true);
                } else {
                    setCommander2Enabled(false);
                }
                }
            });

            // Commander 2 suggest (ONLY is:partner)
            attachSuggest({
                inputEl: commander2Input,
                boxEl: commander2Box,
                spinnerEl: commander2Spinner,
                endpointUrlBuilder: (q) => `/api/partner_suggest?q=${encodeURIComponent(q)}`,
                onPicked: async (_name) => {
                // no-op; commander2 doesn't change background
                }
            });

        })();
        </script>

    </div>
</body>
</html>
